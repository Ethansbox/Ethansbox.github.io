[{"title":"并发编程：浅谈线程安全问题","url":"http://yoursite.com/passages/并发编程/并发编程：浅谈线程安全问题/","content":"<h2 id=\"一、一个简单的例子\"><a href=\"#一、一个简单的例子\" class=\"headerlink\" title=\"一、一个简单的例子\"></a>一、一个简单的例子</h2><p>通过实现Runnable的接口的方式实现线程，在实现类中添加一个成员变量 i，在run方法中通过对i的判断跳出循环结束线程，在main方法中定义两个线程对象同时来操作这个Runnable对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"number : \"</span> + i++);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">50</span> == i) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(myThread);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(myThread);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>部分执行结果：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-01.png?raw=true\" alt=\"执行结果\"></p>\n<p>可以看到，在输出的结果中，有的计数输出一次，有的输出两次，有的顺序是乱的，thread1和thread2是并行的，这两个线程运行时，操作的是同一个Runnable对象，而i又是成员变量，所以两个线程访问的是同一个 i 变量，在运行中，假设运行到 i=10 的时候，thread1线程拿到了这个 i=10 的值，同时thread2也拿到了 i=10 的值，然后thread1对i进行的自增操作，此时 i=11；thread2又将它拿到的 i=10 加一并且写回去，即又进行了一次 i=11的赋值，所以会出现这种错乱的结果。</p>\n<hr>\n<p>将 i 放到局部变量中，测试方法和上面一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"number : \"</span> + i++);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">50</span> == i) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-02.png?raw=true\" alt=\"执行结果\"></p>\n<p>可以看到，一对一对的打印，并且都顺序执行到了最后一个，这是因为将 i 放到了局部变量中，只有当执行到了run方法的时候，这个 i 才会被创建，两个线程操作的 i 不是同一个，所以互不影响。</p>\n<h2 id=\"二、银行取钱案例\"><a href=\"#二、银行取钱案例\" class=\"headerlink\" title=\"二、银行取钱案例\"></a>二、银行取钱案例</h2><p>有这样一个场景：在银行里有人工柜台和自助取款机，假设银行账户里有1000元，如果在同一时间，从柜台取了800元，那么账户里只剩下200元，并且同时尝试从自助取款机取800元，这时取款机会告诉你余额不足。我们用两个线程来模拟这个场景，一个线程为柜台取款，一个线程为取款机取款。</p>\n<p>银行账户类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMoney</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (number &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (number &gt; money)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            money -= number;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"left money: \"</span> + money);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MoneyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Bank bank;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MoneyThread</span><span class=\"params\">(Bank bank)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bank = bank;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(bank.getMoney(<span class=\"number\">800</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Bank bank = <span class=\"keyword\">new</span> Bank();</span><br><span class=\"line\"></span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> MoneyThread(bank);</span><br><span class=\"line\">    Thread t2 = <span class=\"keyword\">new</span> MoneyThread(bank);</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-03.png?raw=true\" alt=\"银行案例打印结果\"></p>\n<p>可以看到出现了这么一种结果（并不是每次运行都会出现这样的结果，这是其中一种情况），第一次取钱取到了800，账户还剩200，第二次取钱取到了800，账户还剩-600，但我们在getMoney这个方法里应该是判断了余额是否小于取款金额的，如果余额小于取款金额，应该返回的是-2而不会去减少余额，这与预期不一样。</p>\n<p>假设线程微观上存在先后顺序，比如线程一先进入了getMoney，此时余额还是1000，那么程序就会跳到最后一个else分支，然后线程就sleep了，同时第二个线程也进入到了getMoney，因为第一个线程sleep了，所以还没有减少余额，那么第二个线程看到的余额也是1000，也进入到了最后一个else分支，这样一来，余额就被减少了两次。</p>\n<p>那么想要达到我们预期的效果，就需要使一个线程执行getMoney方法时，另一个线程不能进入getMoney方法，直到第一个线程执行完了之后再让第二个线程进入方法。Java为我们提供了锁的机制，也就是synchronized关键字。</p>\n<h2 id=\"三、synchronized的简单使用\"><a href=\"#三、synchronized的简单使用\" class=\"headerlink\" title=\"三、synchronized的简单使用\"></a>三、synchronized的简单使用</h2><h3 id=\"3-1-synchronized修饰方法\"><a href=\"#3-1-synchronized修饰方法\" class=\"headerlink\" title=\"3.1 synchronized修饰方法\"></a>3.1 synchronized修饰方法</h3><p>对于上面提到这种情况，可以在方法上加上synchronized修饰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">getMoney</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>加上之后，无论执行多少次，结果都是一样：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-04.png?raw=true\" alt=\"synchronized\"></p>\n<p>加上synchronized修饰之后，在没有线程访问这个方法之前（锁没有被获取），来了一个线程访问了这个方法（获取了锁），在这个线程执行这个方法时，有其他方法试图访问这个方法时（试图获取锁），将会被阻塞，直到获取了锁的线程执行完这个方法然后释放了锁，被阻塞的线程就会再次去尝试获取锁。这样一来，就不会出现两个线程同时访问这个方法的情况。</p>\n<h4 id=\"3-1-1-synchronized修饰两个方法\"><a href=\"#3-1-1-synchronized修饰两个方法\" class=\"headerlink\" title=\"3.1.1 synchronized修饰两个方法\"></a>3.1.1 synchronized修饰两个方法</h4><p>定义一个Number类，其中有两个方法，一个为getOne，会睡眠两秒然后输出one，一个为getTwo，直接输出two，两个方法都用synchronized关键字修饰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Number</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getOne</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getTwo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建两个线程，分别来调用这两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Number number = <span class=\"keyword\">new</span> Number();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            number.getOne();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            number.getTwo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：两秒钟后输出one、two</p>\n<p><img src=\"C:%5CUsers%5CAdministrator%5Cblog%5Cpublic%5Cimages%5C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-05.png\" alt=\"3.1.1运行结果\"></p>\n<p>由于getOne方法中睡眠了两秒，而one还先输出，所以可以判断出在第一个线程调用getOne时，第二个线程被阻塞了。getOne方法和getTwo方法需要获得的锁是同一个锁。</p>\n<h4 id=\"3-1-2-synchronized修饰一个方法\"><a href=\"#3-1-2-synchronized修饰一个方法\" class=\"headerlink\" title=\"3.1.2 synchronized修饰一个方法\"></a>3.1.2 synchronized修饰一个方法</h4><p>去掉getTwo方法的synchronized关键字修饰，其余不变，其输出结果为：</p>\n<p><img src=\"C:%5CUsers%5CAdministrator%5Cblog%5Cpublic%5Cimages%5C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-06.png\" alt=\"3.1.2运行结果\"></p>\n<p>控制台中先输出了two，过了两秒输出了one，可见这次在第一个线程获取了锁之后，线程二并没有被阻塞，也就是说调用getTwo方法不需要获得锁。</p>\n<h3 id=\"3-2-synchronized、static修饰方法\"><a href=\"#3-2-synchronized、static修饰方法\" class=\"headerlink\" title=\"3.2 synchronized、static修饰方法\"></a>3.2 synchronized、static修饰方法</h3><p>用synchronized关键字修饰getOne方法、用synchronized、static修饰getTwo方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Number</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getOne</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getTwo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试方法和上面一样，输出结果为：先输出two，过了两秒再输出one。</p>\n<p>这个结果和3.1.2的一样，也就是说第一个线程获得锁后，第二个线程并没有被阻塞。这里就要说一下，第一个线程获得的锁，是修饰在非静态方法上的，那么这是一个对象锁，也就是在main中定义的number对象的锁。而getTwo方法是静态方法，获取的是Number.class这个类对象的锁，也叫类锁，调用这两个方法锁需要获取的锁不是同一个锁，所以互相不影响。</p>\n<p>那么如果两个方法都加上static，运行结果就会为：过两秒后输出one，再输出two，因为这时两个方法需要获得的锁都是Number.class这个类对象的锁，是同一把锁，那么就会阻塞。</p>\n<h3 id=\"3-3-synchronized代码块\"><a href=\"#3-3-synchronized代码块\" class=\"headerlink\" title=\"3.3 synchronized代码块\"></a>3.3 synchronized代码块</h3><p>除了用synchronized修饰方法，还可以使用类似静态代码块的方法来达到同样的效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(object)&#123;</span><br><span class=\"line\">\tdoSomething;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 方法是一种粗粒度的并法控制，某一时刻，只能有一个线程执行该synchronized方法。synchronized块则是一种细粒度的并法控制，只会将块中的代码同步，位于方法内、synchronized块之外的代码是可以被多个线程同时访问到的。</p>\n<p>括号中的object可以填this，就可以达到普通synchronized方法的效果，也可以填当前类的class对象，这样就可以达到static synchronized同时修饰的效果。</p>\n<h3 id=\"四、简单理解Java内存模型（JMM）和内存可见性\"><a href=\"#四、简单理解Java内存模型（JMM）和内存可见性\" class=\"headerlink\" title=\"四、简单理解Java内存模型（JMM）和内存可见性\"></a>四、简单理解Java内存模型（JMM）和内存可见性</h3><p>Java内存模型规定了所有的变量都存储在主内存中，而每个线程都会将自己所要进行操作的变量复制一个副本到线程自己的工作内存当中，这样线程在操作数据时，只需操作工作内存中的副本，操作完后写回主内存中即可，而不必去直接操作主内存中的数据。</p>\n<p><img src=\"C:%5CUsers%5CAdministrator%5Cblog%5Cpublic%5Cimages%5C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%5C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-07.png\" alt=\"JMM\"></p>\n","categories":["并发编程"],"tags":["java","并发编程"]},{"title":"并发编程：简单理解多线程的实现","url":"http://yoursite.com/passages/并发编程/并发编程：简单理解多线程的实现/","content":"<h2 id=\"一、创建线程\"><a href=\"#一、创建线程\" class=\"headerlink\" title=\"一、创建线程\"></a>一、创建线程</h2><p>创建线程有如下四种方式</p>\n<ul>\n<li><p>继承Thread类并重写run方法；</p>\n</li>\n<li><p>通过实现Runnable接口的类并且实现run方法；</p>\n</li>\n<li><p>实现Callable接口通过FutureTask包装器来创建Thread线程；</p>\n</li>\n<li><p>使用ExecutorService、Callable、Future实现有返回结果的多线程（使用ExecutorService来管理前三种方式）</p>\n</li>\n</ul>\n<p>本文介绍前两种方式</p>\n<h3 id=\"1-1继承Thread创建线程的代码实现\"><a href=\"#1-1继承Thread创建线程的代码实现\" class=\"headerlink\" title=\"1.1继承Thread创建线程的代码实现\"></a>1.1继承Thread创建线程的代码实现</h3><p>创建一个线程类，继承Thread，重写run()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过main方法测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread thread1 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        MyThread thread2 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动线程的方法为Thread.start()，而需要让线程完成的操作重写在Thread.run()里。</p>\n<h3 id=\"1-2实现Runnable接口的类并实现run方法\"><a href=\"#1-2实现Runnable接口的类并实现run方法\" class=\"headerlink\" title=\"1.2实现Runnable接口的类并实现run方法\"></a>1.2实现Runnable接口的类并实现run方法</h3><p> 实现Runnable接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过Thread构造方法来创建新的线程，参数类型应为Runnable的实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnableTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与继承Thread类方式一样，也需要通过Thread.start()来启动线程。</p>\n<h2 id=\"二、Java多线程实现分析\"><a href=\"#二、Java多线程实现分析\" class=\"headerlink\" title=\"二、Java多线程实现分析\"></a>二、Java多线程实现分析</h2><h3 id=\"2-1-Java中初始化线程的过程\"><a href=\"#2-1-Java中初始化线程的过程\" class=\"headerlink\" title=\"2.1 Java中初始化线程的过程\"></a>2.1 Java中初始化线程的过程</h3><p>首先点开java.lang.Thread会发现，实际上Thread类也实现了Runnable接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在Thread类中，实现了run()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个方法中，对target进行判断是否为空，如果target不为空则执行target.run()，找到target被定义的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Runnable target;</span><br></pre></td></tr></table></figure>\n\n<p>target是一个Runnable的对象，前面两种实现方式分别用到了Thread()、Thread(Runnable)构造方法，找到这两个构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       init(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"Thread-\"</span> + nextThreadNum(), <span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread</span><span class=\"params\">(Runnable target)</span> </span>&#123;</span><br><span class=\"line\">       init(<span class=\"keyword\">null</span>, target, <span class=\"string\">\"Thread-\"</span> + nextThreadNum(), <span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个构造方法调用了init方法，找到init方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  <span class=\"keyword\">long</span> stackSize)</span> </span>&#123;</span><br><span class=\"line\">    init(g, target, name, stackSize, <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而这个init方法又调用了另外一个init方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Initializes a Thread.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> g the Thread group</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target the object whose run() method gets called</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> name the name of the new Thread</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class=\"line\"><span class=\"comment\">    *        zero to indicate that this parameter is to be ignored.</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class=\"line\"><span class=\"comment\">    *            AccessController.getContext() if null</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> inheritThreadLocals if &#123;<span class=\"doctag\">@code</span> true&#125;, inherit initial values for</span></span><br><span class=\"line\"><span class=\"comment\">    *            inheritable thread-locals from the constructing thread</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"name cannot be null\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">       Thread parent = currentThread();</span><br><span class=\"line\">       SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (g == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">/* Determine if it's an applet or not */</span></span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">/* If there is a security manager, ask the security manager</span></span><br><span class=\"line\"><span class=\"comment\">              what to do. */</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               g = security.getThreadGroup();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class=\"line\"><span class=\"comment\">              use the parent thread group. */</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (g == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               g = parent.getThreadGroup();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class=\"line\"><span class=\"comment\">          explicitly passed in. */</span></span><br><span class=\"line\">       g.checkAccess();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * Do we have the required permissions?</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class=\"line\">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       g.addUnstarted();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.group = g;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.daemon = parent.isDaemon();</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.priority = parent.getPriority();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (security == <span class=\"keyword\">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.inheritedAccessControlContext =</span><br><span class=\"line\">               acc != <span class=\"keyword\">null</span> ? acc : AccessController.getContext();</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">       setPriority(priority);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.inheritableThreadLocals =</span><br><span class=\"line\">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class=\"line\">       <span class=\"comment\">/* Stash the specified stack size in case the VM cares */</span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.stackSize = stackSize;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">/* Set thread ID */</span></span><br><span class=\"line\">       tid = nextThreadID();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这是初始化一个线程的核心方法，并且是private的</p>\n<p>实现线程的两种方式，第一种继承了Thread类，重写了run方法，而没有重写start方法，所以start方法还是原来父类Thread的start方法，第二种通过传入Runnable对象构造Thread对象，也用的是Thread的start方法，那么看看start方法做了什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class=\"line\"><span class=\"comment\"> * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The result is that two threads are running concurrently: the</span></span><br><span class=\"line\"><span class=\"comment\"> * current thread (which returns from the call to the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * It is never legal to start a thread more than once.</span></span><br><span class=\"line\"><span class=\"comment\"> * In particular, a thread may not be restarted once it has completed</span></span><br><span class=\"line\"><span class=\"comment\"> * execution.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class=\"line\"><span class=\"comment\"> *               started.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>        #run()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>        #stop()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This method is not invoked for the main method thread or \"system\"</span></span><br><span class=\"line\"><span class=\"comment\">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class=\"line\"><span class=\"comment\">     * to this method in the future may have to also be added to the VM.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * A zero status value corresponds to state \"NEW\".</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Notify the group that this thread is about to be started</span></span><br><span class=\"line\"><span class=\"comment\">     * so that it can be added to the group's list of threads</span></span><br><span class=\"line\"><span class=\"comment\">     * and the group's unstarted count can be decremented. */</span></span><br><span class=\"line\">    group.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* do nothing. If start0 threw a Throwable then</span></span><br><span class=\"line\"><span class=\"comment\">              it will be passed up the call stack */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>start()会调用start0()方法，start0是一个native方法，看不到底层实现，但start方法前面的注释已经说的很明白了：“Java虚拟机将会执行这个线程对象的run方法”。回到一开始，run方法对target对象进行了判断，如果target为空，那么run方法将什么都不做，如果target不为空，则调用target.run()。而通过查看源码发现，如果使用的是Thread()构造方法，调用init方法时，传入的target为null，如果使用的是Thread(Runnable)构造方法，调用init方法时，传入的Runnable将会赋值给最终的target，也就是说，通过继承Thread方法实现线程时，最终将会被调用的是重写后的run方法，如果通过实现Runnable创建线程时，最终将会调用传入构造方法的Runnable的run()方法。</p>\n<h3 id=\"2-2-两种实现方式的比较\"><a href=\"#2-2-两种实现方式的比较\" class=\"headerlink\" title=\"2.2 两种实现方式的比较\"></a>2.2 两种实现方式的比较</h3><p>不管使用哪种方式，最终都会通过java.lang.Thread的start方法来执行线程，在这一点上两者是一样的，区别在于继承Thread的本质是通过重写父类的run方法来让线程去执行我们想要执行的代码，而通过传入Runnable对象的本质是实现run方法，并且让Thread对象去执行Runnable对象的run方法来执行我们想要执行的代码。</p>\n<p>前面还提到，Thread也实现了Runnable接口，那么说明一个Thread对象或者Thread子类的对象也是一个Runnable对象，在调用Thread(Runnable)构造方法的时候，我们也可以传入一个Thread对象或者Thread子类的对象，来让一个线程去调用另外一个线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread thread1 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(thread1);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java中，类不能继承多个，接口却能实现多个，所以如果考虑到扩展性以及原本就继承了其他类，优先使用实现Runnable的方式来实现多线程。</p>\n<h2 id=\"三、使用多线程应该注意的问题\"><a href=\"#三、使用多线程应该注意的问题\" class=\"headerlink\" title=\"三、使用多线程应该注意的问题\"></a>三、使用多线程应该注意的问题</h2><h3 id=\"3-1-一个线程只能被启动一次\"><a href=\"#3-1-一个线程只能被启动一次\" class=\"headerlink\" title=\"3.1 一个线程只能被启动一次\"></a>3.1 一个线程只能被启动一次</h3><p>在start方法前的注释有这么一句话：”It is never legal to start a thread more than once.”，就是说一个线程只允许被启动一次，如果尝试多次启动，将会抛出IllegalThreadStateException异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread thread1 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</span><br><span class=\"line\">\tat java.lang.Thread.start(Thread.java:708)</span><br><span class=\"line\">\tat com.ethan.MyThreadTest.main(MyThreadTest.java:9)</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-停止线程\"><a href=\"#3-2-停止线程\" class=\"headerlink\" title=\"3.2 停止线程\"></a>3.2 停止线程</h3><p>在Java中有以下3种方法可以终止正在运行的线程：</p>\n<ul>\n<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>\n<li>使用stop方法强行终止线程，但是实际上不要去使用这个方法，因为stop、suspend、resume都是已经作废过期的方法，使用这些方法有可能产生不可预料的结果。</li>\n<li>使用interrupt方法中断线程</li>\n</ul>\n<h4 id=\"3-2-1使用退出标志终止线程\"><a href=\"#3-2-1使用退出标志终止线程\" class=\"headerlink\" title=\"3.2.1使用退出标志终止线程\"></a>3.2.1使用退出标志终止线程</h4><p>这种方法主要用于线程中有循环执行的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程的实现类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程停止标志，为true则让线程停止</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isstopping = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isstopping) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//调用此方法，让run方法跳出循环</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopRunning</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        isstopping = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//控制类，控制线程的启动与停止</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControlThread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyThread runnable = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread thread = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        runnable.stopRunning();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main方法测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ControlThread controlThread = <span class=\"keyword\">new</span> ControlThread();</span><br><span class=\"line\">        controlThread.startThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        controlThread.stopThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"number\">51</span></span><br><span class=\"line\"><span class=\"number\">52</span></span><br><span class=\"line\"><span class=\"number\">53</span></span><br><span class=\"line\"><span class=\"number\">54</span></span><br><span class=\"line\"><span class=\"number\">55</span></span><br><span class=\"line\"><span class=\"number\">56</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这种方法确实能起到停止线程的效果，但存在诸多弊端。首先这种方式非常的麻烦，又要实现线程类、还要创建一个线程的控制类，局限性也非常的大。并且如果for循环之后还有其他的代码，也将会被执行，不能起到真正停止线程的效果。</p>\n<h4 id=\"3-2-2使用interrupt方法中断线程\"><a href=\"#3-2-2使用interrupt方法中断线程\" class=\"headerlink\" title=\"3.2.2使用interrupt方法中断线程\"></a>3.2.2使用interrupt方法中断线程</h4><p>参考《Java多线程编程核心技术》的1.7节发现，实际上，调用interrupt方法并不能真正的停止线程，只能给线程打上一个停止的标记。但Thread中还有两个方法，分别是interrupted()和isInterrupted()</p>\n<ul>\n<li><p>interrupted</p>\n<p>在文档中是这么描述的”Tests whether the current thread has been interrupted”，也就是说，这个方法是用来测试当前线程是否被interrupte的，这点在源码中能找到证据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentThread().isInterrupted(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而currentThread()返回的是执行当前线程的线程，这个方法被标注为static方法，也就是说可以通过Thread.interrupted()来用类调用这个方法，也可以用普通的thread线程对象来调用这个方法，只不过用普通的thread线程对象来调用时，与通过类来调用的效果是一样的，并不会去判断thread类是否被中断</p>\n<p>中断thread1线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"是否停止thread1?=\"</span>+thread1.interrupted());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是否停止thread1?=false</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>中断main线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"是否停止1?\"</span>+Thread.interrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"是否停止2?=\"</span>+Thread.interrupted());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是否停止1?true</span><br><span class=\"line\">是否停止2?=false</span><br></pre></td></tr></table></figure>\n\n<p>那么又出现了一个问题：为什么第一次判断时是ture而第二次判断则为false?</p>\n<p>在文档中，对interrupted()方法的描述还有这么一句话”The <em>interrupted status</em> of the thread is cleared by this method. “也就是说这个方法将会清除线程的中断状态，接下来再看一下被interrupted()方法调用了的isInterrupted()方法。</p>\n</li>\n<li><p>isInterrupted()</p>\n<p>在文档中是这么描述的”Tests whether this thread has been interrupted. The <em>interrupted status</em> of the thread is unaffected by this method.”可以看出这个方法测试的是调用这个方法的线程对象是否被中断，并且不会清除线程的中断状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInterrupted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isInterrupted(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个isInterrupted()方法还调用了另一个重载的方法，并且这个方法是private、native修饰的</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0-01.png?raw=true\" alt=\"isInterrupted\"></p>\n<p>在注释中还提到，中断状态是否被清除，是由传入参数ClearInterrupted决定的，而interrupted()调用此方法时传入的是true，isInterrupted()调用此方法时传入的是false，这也与文档的描述相应证了。</p>\n</li>\n</ul>\n<hr>\n<p>有了这两个方法之后，就可以用类似前面那种退出标志的方法来终止线程了，这样的话不用我们自己来写控制中断线程标志的方法，但是循环之后的代码会被继续执行的问题还是没有得到解决，结合抛出异常可以解决这个问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.interrupted())&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"已停止\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"异常被捕获\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread thread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        thread.interrupt();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">已停止</span><br><span class=\"line\">异常被捕获</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式，就能够达到让线程停下来的效果。</p>\n<h3 id=\"3-3线程命名\"><a href=\"#3-3线程命名\" class=\"headerlink\" title=\"3.3线程命名\"></a>3.3线程命名</h3><p>在前面分析构造线程的过程中，可以看到调用init方法时传入了一个叫name的参数，这个参数就是线程的名字，当没有调用传入线程名的构造方法时，会自动传入一个名字，这个名字为”Thread-“ + nextThreadNum()，nextThreadNum方法将会执行threadInitNumber++，threadInitNumber是一个静态成员变量，也就是说，当我们不给线程命名时，系统会自动为线程命名，并且这个命名是一个所有线程共享的计数器，每创建一个线程，这个计数器就会+1:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            MyThread thread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">            System.out.println(thread.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-0</span><br><span class=\"line\">Thread-1</span><br><span class=\"line\">Thread-2</span><br><span class=\"line\">Thread-3</span><br><span class=\"line\">Thread-4</span><br></pre></td></tr></table></figure>\n\n<p>当我们使用线程时，最好给它指定一个名字，这对排错诊断系统监控有帮助。否则诊断问题时，无法直观知道某个线程的用途。</p>\n","categories":["并发编程"],"tags":["java","并发编程"]},{"title":"用栈实现队列","url":"http://yoursite.com/passages/算法修炼/栈和队列/用栈实现队列/","content":"","categories":["算法修炼","栈和队列"],"tags":["算法","栈和队列"]},{"title":"最小值栈","url":"http://yoursite.com/passages/算法修炼/栈和队列/最小值栈/","content":"","categories":["算法修炼","栈和队列"],"tags":["算法","栈和队列"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"categories","url":"http://yoursite.com/categories/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"http://yoursite.com/tags/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]