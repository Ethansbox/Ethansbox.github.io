[{"title":"并发编程：理解原子操作与CAS","url":"http://yoursite.com/passages/并发编程/并发编程：理解原子操作与CAS/","content":"<h2 id=\"一、原子操作基本概念\"><a href=\"#一、原子操作基本概念\" class=\"headerlink\" title=\"一、原子操作基本概念\"></a>一、原子操作基本概念</h2><p>原子即不能被分割的最小粒子，原子操作则意味“不可被中断的一个或一系列操作”，如果一个操作是原子性的，那么可以这个操作就可以很大程度上地避免线程安全问题。由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，大致可以认定为基本数据的访问读写是具备原子性的（但由于long、和double是64位的，在32位的处理器上执行时则不能保证原子性），而i++不是一个原子性操作，它包括读-改-写三步操作。Java提供的synchronized块直接的操作也具备原子性。</p>\n<h2 id=\"二、比较并交换（CAS）\"><a href=\"#二、比较并交换（CAS）\" class=\"headerlink\" title=\"二、比较并交换（CAS）\"></a>二、比较并交换（CAS）</h2><p>在Java中除了通过锁来实现原子操作外，还可以通过循环CAS的方式来实现原子操作。</p>\n<p>简单来说，CAS就是通过比较内存中的变量和预期值，如果相等，才执行更新操作，这样就能达到原子操作的效果。CAS指令需要有3个操作数，分别为内存位置（用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程为一个原子操作。</p>\n<p>首先来看一个变量操作不具备原子性的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> race = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        race++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread[] threads = <span class=\"keyword\">new</span> Thread[<span class=\"number\">20</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            threads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                        increase();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            threads[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">2</span>)</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(race);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码发起了20个线程，每个线程对race变量进行10000此自增操作，如果这段代码能正确并发的话，最后输出的结果应该是200000，但运行之后，并不会获得这个结果，而总是获得一个小于200000的值，并且每次都不一样。前面《浅谈线程安全问题》有提到，volatile变量在各个线程中是一致的，也就是说，线程A看到的race变量和线程B看到的race变量，应该是同一个值。但问题出在自增运算“race++”并不是一个原子操作，我们说race++是一个读-改-写操作，那么这个“改”操作可以简单理解为有一个中间变量temp来接收了race + 1的值（底层并不是这么实现的，但是这个场景下可以这样描述有便于理解），而这个temp并不能反映到其他的线程当中，所以即使race被标记为volatile变量，但race++仍然不是线程安全的。</p>\n<p>在JDK1.5之后，JDK的并发包里提供了一些类了哎支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些类都有一个方法就是compareAndSet方法，也就是前面提到的CAS，这个 方法是用来保证更新值为原子性的，接下来使用循环CAS的方式来实现数据操作的原子性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AtomicInteger race = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = race.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> suc = race.compareAndSet(current,next);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (suc)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread[] threads = <span class=\"keyword\">new</span> Thread[<span class=\"number\">20</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            threads[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">                        increase();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            threads[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (Thread.activeCount()&gt;<span class=\"number\">2</span>)</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(race);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改之后，无论执行多少次，得到的结果总是200000，JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，在AtomicInteger类里，还有一个方法：incrementAndGet，也就是具备原子性的自增操作，通过使用这个方法，可以省去上面略显繁琐的CAS自旋：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">increase</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    race.incrementAndGet();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将increase方法改为上面这样后，也可以实现同样的效果。</p>\n<p>笔者所使用的JDK版本为JDK1.8，incrementAndGet的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Atomically increments by one the current value.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the updated value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在JDK1.7中incrementAndGet的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Atomically increments by one the current value.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> the updated value</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> current = get();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在JDK1.7中，该方法去调用了compareAndSet方法，也是通过CAS自旋来实现原子性操作的，而JDK1.8中的incrementAndGet方法和compareAndSet都是调用了Unsafe类里的native方法利用处理器提供的CMPXCHG指令实现原子性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Atomically sets the value to the given updated value</span></span><br><span class=\"line\"><span class=\"comment\"> * if the current value &#123;<span class=\"doctag\">@code</span> ==&#125; the expected value.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> expect the expected value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> update the new value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class=\"line\"><span class=\"comment\"> * the actual value was not equal to the expected value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AtomicInteger的compareAndSet方法调用了unsafe的compareAndSwapInt方法，传入值分别为当前这个对象、这个数字所对应的对象”value”（一个成员变量）的偏移量（也就是一个字段到对象头部的偏移量，通过这个偏移量可以快速定位字段）、预期修改前的值、修改后的值。</p>\n<h2 id=\"三、CAS实现原子操作的三大问题\"><a href=\"#三、CAS实现原子操作的三大问题\" class=\"headerlink\" title=\"三、CAS实现原子操作的三大问题\"></a>三、CAS实现原子操作的三大问题</h2><p>CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题：ABA问题，如果循环时间长开销会很大，以及纸就能保证一个共享变量的原子操作。</p>\n<h3 id=\"3-1ABA问题\"><a href=\"#3-1ABA问题\" class=\"headerlink\" title=\"3.1ABA问题\"></a>3.1ABA问题</h3><p>CAS在更新值时，会先检查值有没有变化，如果值与预期的一样，则进行修改。那么如果一个值原本是A，中途被修改了，然后又被修改为A，这种情况下，使用CAS去检查它的值会认为它没有变化，但实际上中间有变化过。这个漏洞称为CAS操作的“ABA”问题。</p>\n<p>解决方案：ABA问题的解决思路就是使用版本号。给变量追加上版本号，每次更新时就把版本号加 1，那么A → B →A就变成了1A→2B→3A。J.U.C包中提供了一个带有标记的原子引用类“AtomicStampedReference”，这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果引用和标志都相等，则以原子方式将该引用和该标志的值设置为给定的更新值。但在实际中，大部分情况下ABA问题不会影响程序并发的正确性，如果真的需要解决ABA问题，改用互斥同步可能会更好。</p>\n<h3 id=\"3-2循环时间长开销大\"><a href=\"#3-2循环时间长开销大\" class=\"headerlink\" title=\"3.2循环时间长开销大\"></a>3.2循环时间长开销大</h3><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定提升。pause指令有两个作用：第一，它可以延迟流水线执行指令，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。</p>\n<h3 id=\"3-3只能保证一个共享变量的原子操作\"><a href=\"#3-3只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"3.3只能保证一个共享变量的原子操作\"></a>3.3只能保证一个共享变量的原子操作</h3><p>当对一个共享变量执行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</p>\n<p>解决方案：可以用锁来保证多个变量操作的原子性。还有一个办法，在J.U.C包中还提供了一个AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>\n","categories":["并发编程"],"tags":["java","并发编程"]},{"title":"并发编程：浅谈线程安全问题","url":"http://yoursite.com/passages/并发编程/并发编程：浅谈线程安全问题/","content":"<h2 id=\"一、一个简单的例子\"><a href=\"#一、一个简单的例子\" class=\"headerlink\" title=\"一、一个简单的例子\"></a>一、一个简单的例子</h2><p>通过实现Runnable的接口的方式实现线程，在实现类中添加一个成员变量 i，在run方法中通过对i的判断跳出循环结束线程，在main方法中定义两个线程对象同时来操作这个Runnable对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"number : \"</span> + i++);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">50</span> == i) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(myThread);</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(myThread);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>部分执行结果：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-01.png?raw=true\" alt=\"执行结果\"></p>\n<p>可以看到，在输出的结果中，有的计数输出一次，有的输出两次，有的顺序是乱的，thread1和thread2是并行的，这两个线程运行时，操作的是同一个Runnable对象，而i又是成员变量，所以两个线程访问的是同一个 i 变量，在运行中，假设运行到 i=10 的时候，thread1线程拿到了这个 i=10 的值，同时thread2也拿到了 i=10 的值，然后thread1对i进行的自增操作，此时 i=11；thread2又将它拿到的 i=10 加一并且写回去，即又进行了一次 i=11的赋值，所以会出现这种错乱的结果。</p>\n<hr>\n<p>将 i 放到局部变量中，测试方法和上面一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"number : \"</span> + i++);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">50</span> == i) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-02.png?raw=true\" alt=\"执行结果\"></p>\n<p>可以看到，一对一对的打印，并且都顺序执行到了最后一个，这是因为将 i 放到了局部变量中，只有当执行到了run方法的时候，这个 i 才会被创建，两个线程操作的 i 不是同一个，所以互不影响。</p>\n<h2 id=\"二、银行取钱案例\"><a href=\"#二、银行取钱案例\" class=\"headerlink\" title=\"二、银行取钱案例\"></a>二、银行取钱案例</h2><p>有这样一个场景：在银行里有人工柜台和自助取款机，假设银行账户里有1000元，如果在同一时间，从柜台取了800元，那么账户里只剩下200元，并且同时尝试从自助取款机取800元，这时取款机会告诉你余额不足。我们用两个线程来模拟这个场景，一个线程为柜台取款，一个线程为取款机取款。</p>\n<p>银行账户类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> money = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMoney</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (number &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (number &gt; money)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (money &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            money -= number;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"left money: \"</span> + money);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MoneyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Bank bank;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MoneyThread</span><span class=\"params\">(Bank bank)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bank = bank;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(bank.getMoney(<span class=\"number\">800</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Bank bank = <span class=\"keyword\">new</span> Bank();</span><br><span class=\"line\"></span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> MoneyThread(bank);</span><br><span class=\"line\">    Thread t2 = <span class=\"keyword\">new</span> MoneyThread(bank);</span><br><span class=\"line\"></span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-03.png?raw=true\" alt=\"银行案例打印结果\"></p>\n<p>可以看到出现了这么一种结果（并不是每次运行都会出现这样的结果，这是其中一种情况），第一次取钱取到了800，账户还剩200，第二次取钱取到了800，账户还剩-600，但我们在getMoney这个方法里应该是判断了余额是否小于取款金额的，如果余额小于取款金额，应该返回的是-2而不会去减少余额，这与预期不一样。</p>\n<p>假设线程微观上存在先后顺序，比如线程一先进入了getMoney，此时余额还是1000，那么程序就会跳到最后一个else分支，然后线程就sleep了，同时第二个线程也进入到了getMoney，因为第一个线程sleep了，所以还没有减少余额，那么第二个线程看到的余额也是1000，也进入到了最后一个else分支，这样一来，余额就被减少了两次。</p>\n<p>那么想要达到我们预期的效果，就需要使一个线程执行getMoney方法时，另一个线程不能进入getMoney方法，直到第一个线程执行完了之后再让第二个线程进入方法。Java为我们提供了锁的机制，也就是synchronized关键字。</p>\n<h2 id=\"三、synchronized的简单使用\"><a href=\"#三、synchronized的简单使用\" class=\"headerlink\" title=\"三、synchronized的简单使用\"></a>三、synchronized的简单使用</h2><h3 id=\"3-1-synchronized修饰方法\"><a href=\"#3-1-synchronized修饰方法\" class=\"headerlink\" title=\"3.1 synchronized修饰方法\"></a>3.1 synchronized修饰方法</h3><p>对于上面提到这种情况，可以在方法上加上synchronized修饰：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">getMoney</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>加上之后，无论执行多少次，结果都是一样：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-04.png?raw=true\" alt=\"synchronized\"></p>\n<p>加上synchronized修饰之后，在没有线程访问这个方法之前（锁没有被获取），来了一个线程访问了这个方法（获取了锁），在这个线程执行这个方法时，有其他方法试图访问这个方法时（试图获取锁），将会被阻塞，直到获取了锁的线程执行完这个方法然后释放了锁，被阻塞的线程就会再次去尝试获取锁。这样一来，就不会出现两个线程同时访问这个方法的情况。</p>\n<h4 id=\"3-1-1-synchronized修饰两个方法\"><a href=\"#3-1-1-synchronized修饰两个方法\" class=\"headerlink\" title=\"3.1.1 synchronized修饰两个方法\"></a>3.1.1 synchronized修饰两个方法</h4><p>定义一个Number类，其中有两个方法，一个为getOne，会睡眠两秒然后输出one，一个为getTwo，直接输出two，两个方法都用synchronized关键字修饰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Number</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getOne</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getTwo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建两个线程，分别来调用这两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Number number = <span class=\"keyword\">new</span> Number();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            number.getOne();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            number.getTwo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为：两秒钟后输出one、two</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-05.png?raw=true\" alt=\"3.1.1运行结果\"></p>\n<p>由于getOne方法中睡眠了两秒，而one还先输出，所以可以判断出在第一个线程调用getOne时，第二个线程被阻塞了。getOne方法和getTwo方法需要获得的锁是同一个锁。</p>\n<h4 id=\"3-1-2-synchronized修饰一个方法\"><a href=\"#3-1-2-synchronized修饰一个方法\" class=\"headerlink\" title=\"3.1.2 synchronized修饰一个方法\"></a>3.1.2 synchronized修饰一个方法</h4><p>去掉getTwo方法的synchronized关键字修饰，其余不变，其输出结果为：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-06.png?raw=true\" alt=\"3.1.2运行结果\"></p>\n<p>控制台中先输出了two，过了两秒输出了one，可见这次在第一个线程获取了锁之后，线程二并没有被阻塞，也就是说调用getTwo方法不需要获得锁。</p>\n<h3 id=\"3-2-synchronized、static修饰方法\"><a href=\"#3-2-synchronized、static修饰方法\" class=\"headerlink\" title=\"3.2 synchronized、static修饰方法\"></a>3.2 synchronized、static修饰方法</h3><p>用synchronized关键字修饰getOne方法、用synchronized、static修饰getTwo方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Number</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getOne</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">getTwo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试方法和上面一样，输出结果为：先输出two，过了两秒再输出one。</p>\n<p>这个结果和3.1.2的一样，也就是说第一个线程获得锁后，第二个线程并没有被阻塞。这里就要说一下，第一个线程获得的锁，是修饰在非静态方法上的，那么这是一个对象锁，也就是在main中定义的number对象的锁。而getTwo方法是静态方法，获取的是Number.class这个类对象的锁，也叫类锁，调用这两个方法锁需要获取的锁不是同一个锁，所以互相不影响。</p>\n<p>那么如果两个方法都加上static，运行结果就会为：过两秒后输出one，再输出two，因为这时两个方法需要获得的锁都是Number.class这个类对象的锁，是同一把锁，那么就会阻塞。</p>\n<h3 id=\"3-3-synchronized代码块\"><a href=\"#3-3-synchronized代码块\" class=\"headerlink\" title=\"3.3 synchronized代码块\"></a>3.3 synchronized代码块</h3><p>除了用synchronized修饰方法，还可以使用类似静态代码块的方法来达到同样的效果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized(object)&#123;</span><br><span class=\"line\">\tdoSomething;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>synchronized 方法是一种粗粒度的并法控制，某一时刻，只能有一个线程执行该synchronized方法。synchronized块则是一种细粒度的并法控制，只会将块中的代码同步，位于方法内、synchronized块之外的代码是可以被多个线程同时访问到的。</p>\n<p>括号中的object可以填this，就可以达到普通synchronized方法的效果，也可以填当前类的class对象，这样就可以达到static synchronized同时修饰的效果。</p>\n<h2 id=\"四、简单理解Java内存模型（JMM）和内存可见性\"><a href=\"#四、简单理解Java内存模型（JMM）和内存可见性\" class=\"headerlink\" title=\"四、简单理解Java内存模型（JMM）和内存可见性\"></a>四、简单理解Java内存模型（JMM）和内存可见性</h2><p>Java内存模型规定了所有的变量都存储在主内存中，而每个线程都会将自己所要进行操作的变量复制一个副本到线程自己的工作内存当中，这样线程在操作数据时，只需操作工作内存中的副本，操作完后写回主内存中即可，而不必去直接操作主内存中的数据。</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-07.png?raw=true\" alt=\"JMM\"></p>\n<p>这样做提高了运行的效率，但这样一来，就产生了内存可见性问题，比如说，主内存中有一个共享变量 i 初始值为1，线程A要对 i 进行 i++ 操作，那么会复制一份共享变量的副本到本地内存A中，当线程A把 i 新的值写回主内存之前，线程B 也要操作 i ，而此时线程B看到的 i 仍然为 1 ，且复制了一份共享变量的副本到本地内存B中，那么线程A修改i的值对于线程B来说是不可见的，最终 i 被加了两次，写在主内存中的却是 2 。</p>\n<h2 id=\"五、volatile的简单使用\"><a href=\"#五、volatile的简单使用\" class=\"headerlink\" title=\"五、volatile的简单使用\"></a>五、volatile的简单使用</h2><p>前面说到了内存可见性问题，那么再举一个简单的例子来理解一下内存可见性问题。</p>\n<p>通过实现Runnable接口实现一个线程类，类中定义一个boolean类型的私有成员变量flag，初始值为false，并为其提供getter/setter方法，run方法里的逻辑是睡眠200毫秒，然后将flag置为true并输出flag的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">200</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"flag=\"</span> + isFlag() );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isFlag</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setFlag</span><span class=\"params\">(<span class=\"keyword\">boolean</span> flag)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.flag = flag;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在main方法中，先定义一个MyThread对象并运行，然后用一个死循环判断flag的值，当flag变为true时，打印语句并跳出循环：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(myThread).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (myThread.isFlag())&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"进入了if语句！\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-08.png?raw=true\" alt=\"测试结果\"></p>\n<p>可以看到，flag被myThread线程置为true并输出了，但是在main方法的死循环中，似乎并没有捕获到flag的变化，没有进入if语句，没有跳出循环，程序也一直没有结束。根据前面讨论的Java内存模型来分析这个问题，myThread线程和main线程的工作内存中都分别有一份flag变量的副本，当myThread值把flag置为true并写入主内存后，main线程一直处于循环当中，也就是flag一直在被调用，没有去比对主内存中flag的值并更新到main的工作内存里，针对于这种情况，可以在声明flag变量时，加上volatile关键字：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<p>再次运行：</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E6%B5%85%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-09.png?raw=true\" alt=\"测试结果\"></p>\n<p>可以看到，程序结束了运行，if语句里代码也被执行了，跳出了死循环，也就是说main线程察觉到了flag变量的更新。</p>\n<p>volatile写的内存语义如下：</p>\n<p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>\n<p>volatile读的内存语义如下：</p>\n<p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>\n<p>volatile还有一个语义是禁止指令重排序优化。</p>\n<p>关于什么是指令重排序，已经volatile内存语义的实现与深入了解JMM会在后续提到。</p>\n","categories":["并发编程"],"tags":["java","并发编程"]},{"title":"并发编程：简单理解多线程的实现","url":"http://yoursite.com/passages/并发编程/并发编程：简单理解多线程的实现/","content":"<h2 id=\"一、创建线程\"><a href=\"#一、创建线程\" class=\"headerlink\" title=\"一、创建线程\"></a>一、创建线程</h2><p>创建线程有如下四种方式</p>\n<ul>\n<li><p>继承Thread类并重写run方法；</p>\n</li>\n<li><p>通过实现Runnable接口的类并且实现run方法；</p>\n</li>\n<li><p>实现Callable接口通过FutureTask包装器来创建Thread线程；</p>\n</li>\n<li><p>使用ExecutorService、Callable、Future实现有返回结果的多线程（使用ExecutorService来管理前三种方式）</p>\n</li>\n</ul>\n<p>本文介绍前两种方式</p>\n<h3 id=\"1-1继承Thread创建线程的代码实现\"><a href=\"#1-1继承Thread创建线程的代码实现\" class=\"headerlink\" title=\"1.1继承Thread创建线程的代码实现\"></a>1.1继承Thread创建线程的代码实现</h3><p>创建一个线程类，继承Thread，重写run()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过main方法测试：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread thread1 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        MyThread thread2 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动线程的方法为Thread.start()，而需要让线程完成的操作重写在Thread.run()里。</p>\n<h3 id=\"1-2实现Runnable接口的类并实现run方法\"><a href=\"#1-2实现Runnable接口的类并实现run方法\" class=\"headerlink\" title=\"1.2实现Runnable接口的类并实现run方法\"></a>1.2实现Runnable接口的类并实现run方法</h3><p> 实现Runnable接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过Thread构造方法来创建新的线程，参数类型应为Runnable的实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnableTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与继承Thread类方式一样，也需要通过Thread.start()来启动线程。</p>\n<h2 id=\"二、Java多线程实现分析\"><a href=\"#二、Java多线程实现分析\" class=\"headerlink\" title=\"二、Java多线程实现分析\"></a>二、Java多线程实现分析</h2><h3 id=\"2-1-Java中初始化线程的过程\"><a href=\"#2-1-Java中初始化线程的过程\" class=\"headerlink\" title=\"2.1 Java中初始化线程的过程\"></a>2.1 Java中初始化线程的过程</h3><p>首先点开java.lang.Thread会发现，实际上Thread类也实现了Runnable接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在Thread类中，实现了run()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个方法中，对target进行判断是否为空，如果target不为空则执行target.run()，找到target被定义的位置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Runnable target;</span><br></pre></td></tr></table></figure>\n\n<p>target是一个Runnable的对象，前面两种实现方式分别用到了Thread()、Thread(Runnable)构造方法，找到这两个构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       init(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"string\">\"Thread-\"</span> + nextThreadNum(), <span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread</span><span class=\"params\">(Runnable target)</span> </span>&#123;</span><br><span class=\"line\">       init(<span class=\"keyword\">null</span>, target, <span class=\"string\">\"Thread-\"</span> + nextThreadNum(), <span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个构造方法调用了init方法，找到init方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                  <span class=\"keyword\">long</span> stackSize)</span> </span>&#123;</span><br><span class=\"line\">    init(g, target, name, stackSize, <span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而这个init方法又调用了另外一个init方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Initializes a Thread.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> g the Thread group</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target the object whose run() method gets called</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> name the name of the new Thread</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class=\"line\"><span class=\"comment\">    *        zero to indicate that this parameter is to be ignored.</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class=\"line\"><span class=\"comment\">    *            AccessController.getContext() if null</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> inheritThreadLocals if &#123;<span class=\"doctag\">@code</span> true&#125;, inherit initial values for</span></span><br><span class=\"line\"><span class=\"comment\">    *            inheritable thread-locals from the constructing thread</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"name cannot be null\"</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">       Thread parent = currentThread();</span><br><span class=\"line\">       SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (g == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"comment\">/* Determine if it's an applet or not */</span></span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">/* If there is a security manager, ask the security manager</span></span><br><span class=\"line\"><span class=\"comment\">              what to do. */</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               g = security.getThreadGroup();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class=\"line\"><span class=\"comment\">              use the parent thread group. */</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (g == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               g = parent.getThreadGroup();</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class=\"line\"><span class=\"comment\">          explicitly passed in. */</span></span><br><span class=\"line\">       g.checkAccess();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * Do we have the required permissions?</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class=\"line\">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       g.addUnstarted();</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.group = g;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.daemon = parent.isDaemon();</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.priority = parent.getPriority();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (security == <span class=\"keyword\">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class=\"line\">       <span class=\"keyword\">else</span></span><br><span class=\"line\">           <span class=\"keyword\">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.inheritedAccessControlContext =</span><br><span class=\"line\">               acc != <span class=\"keyword\">null</span> ? acc : AccessController.getContext();</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">       setPriority(priority);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.inheritableThreadLocals =</span><br><span class=\"line\">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class=\"line\">       <span class=\"comment\">/* Stash the specified stack size in case the VM cares */</span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.stackSize = stackSize;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">/* Set thread ID */</span></span><br><span class=\"line\">       tid = nextThreadID();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这是初始化一个线程的核心方法，并且是private的</p>\n<p>实现线程的两种方式，第一种继承了Thread类，重写了run方法，而没有重写start方法，所以start方法还是原来父类Thread的start方法，第二种通过传入Runnable对象构造Thread对象，也用的是Thread的start方法，那么看看start方法做了什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class=\"line\"><span class=\"comment\"> * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * The result is that two threads are running concurrently: the</span></span><br><span class=\"line\"><span class=\"comment\"> * current thread (which returns from the call to the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * It is never legal to start a thread more than once.</span></span><br><span class=\"line\"><span class=\"comment\"> * In particular, a thread may not be restarted once it has completed</span></span><br><span class=\"line\"><span class=\"comment\"> * execution.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class=\"line\"><span class=\"comment\"> *               started.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>        #run()</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@see</span>        #stop()</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * This method is not invoked for the main method thread or \"system\"</span></span><br><span class=\"line\"><span class=\"comment\">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class=\"line\"><span class=\"comment\">     * to this method in the future may have to also be added to the VM.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * A zero status value corresponds to state \"NEW\".</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Notify the group that this thread is about to be started</span></span><br><span class=\"line\"><span class=\"comment\">     * so that it can be added to the group's list of threads</span></span><br><span class=\"line\"><span class=\"comment\">     * and the group's unstarted count can be decremented. */</span></span><br><span class=\"line\">    group.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> started = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        start0();</span><br><span class=\"line\">        started = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!started) &#123;</span><br><span class=\"line\">                group.threadStartFailed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* do nothing. If start0 threw a Throwable then</span></span><br><span class=\"line\"><span class=\"comment\">              it will be passed up the call stack */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>start()会调用start0()方法，start0是一个native方法，看不到底层实现，但start方法前面的注释已经说的很明白了：“Java虚拟机将会执行这个线程对象的run方法”。回到一开始，run方法对target对象进行了判断，如果target为空，那么run方法将什么都不做，如果target不为空，则调用target.run()。而通过查看源码发现，如果使用的是Thread()构造方法，调用init方法时，传入的target为null，如果使用的是Thread(Runnable)构造方法，调用init方法时，传入的Runnable将会赋值给最终的target，也就是说，通过继承Thread方法实现线程时，最终将会被调用的是重写后的run方法，如果通过实现Runnable创建线程时，最终将会调用传入构造方法的Runnable的run()方法。</p>\n<h3 id=\"2-2-两种实现方式的比较\"><a href=\"#2-2-两种实现方式的比较\" class=\"headerlink\" title=\"2.2 两种实现方式的比较\"></a>2.2 两种实现方式的比较</h3><p>不管使用哪种方式，最终都会通过java.lang.Thread的start方法来执行线程，在这一点上两者是一样的，区别在于继承Thread的本质是通过重写父类的run方法来让线程去执行我们想要执行的代码，而通过传入Runnable对象的本质是实现run方法，并且让Thread对象去执行Runnable对象的run方法来执行我们想要执行的代码。</p>\n<p>前面还提到，Thread也实现了Runnable接口，那么说明一个Thread对象或者Thread子类的对象也是一个Runnable对象，在调用Thread(Runnable)构造方法的时候，我们也可以传入一个Thread对象或者Thread子类的对象，来让一个线程去调用另外一个线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread thread1 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        Thread thread2 = <span class=\"keyword\">new</span> Thread(thread1);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java中，类不能继承多个，接口却能实现多个，所以如果考虑到扩展性以及原本就继承了其他类，优先使用实现Runnable的方式来实现多线程。</p>\n<h2 id=\"三、使用多线程应该注意的问题\"><a href=\"#三、使用多线程应该注意的问题\" class=\"headerlink\" title=\"三、使用多线程应该注意的问题\"></a>三、使用多线程应该注意的问题</h2><h3 id=\"3-1-一个线程只能被启动一次\"><a href=\"#3-1-一个线程只能被启动一次\" class=\"headerlink\" title=\"3.1 一个线程只能被启动一次\"></a>3.1 一个线程只能被启动一次</h3><p>在start方法前的注释有这么一句话：”It is never legal to start a thread more than once.”，就是说一个线程只允许被启动一次，如果尝试多次启动，将会抛出IllegalThreadStateException异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread thread1 = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalThreadStateException</span><br><span class=\"line\">\tat java.lang.Thread.start(Thread.java:708)</span><br><span class=\"line\">\tat com.ethan.MyThreadTest.main(MyThreadTest.java:9)</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-停止线程\"><a href=\"#3-2-停止线程\" class=\"headerlink\" title=\"3.2 停止线程\"></a>3.2 停止线程</h3><p>在Java中有以下3种方法可以终止正在运行的线程：</p>\n<ul>\n<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li>\n<li>使用stop方法强行终止线程，但是实际上不要去使用这个方法，因为stop、suspend、resume都是已经作废过期的方法，使用这些方法有可能产生不可预料的结果。</li>\n<li>使用interrupt方法中断线程</li>\n</ul>\n<h4 id=\"3-2-1使用退出标志终止线程\"><a href=\"#3-2-1使用退出标志终止线程\" class=\"headerlink\" title=\"3.2.1使用退出标志终止线程\"></a>3.2.1使用退出标志终止线程</h4><p>这种方法主要用于线程中有循环执行的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程的实现类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//线程停止标志，为true则让线程停止</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isstopping = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isstopping) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//调用此方法，让run方法跳出循环</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopRunning</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        isstopping = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//控制类，控制线程的启动与停止</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControlThread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyThread runnable = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Thread thread = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopThread</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        runnable.stopRunning();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main方法测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ControlThread controlThread = <span class=\"keyword\">new</span> ControlThread();</span><br><span class=\"line\">        controlThread.startThread();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        controlThread.stopThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"number\">50</span></span><br><span class=\"line\"><span class=\"number\">51</span></span><br><span class=\"line\"><span class=\"number\">52</span></span><br><span class=\"line\"><span class=\"number\">53</span></span><br><span class=\"line\"><span class=\"number\">54</span></span><br><span class=\"line\"><span class=\"number\">55</span></span><br><span class=\"line\"><span class=\"number\">56</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这种方法确实能起到停止线程的效果，但存在诸多弊端。首先这种方式非常的麻烦，又要实现线程类、还要创建一个线程的控制类，局限性也非常的大。并且如果for循环之后还有其他的代码，也将会被执行，不能起到真正停止线程的效果。</p>\n<h4 id=\"3-2-2使用interrupt方法中断线程\"><a href=\"#3-2-2使用interrupt方法中断线程\" class=\"headerlink\" title=\"3.2.2使用interrupt方法中断线程\"></a>3.2.2使用interrupt方法中断线程</h4><p>参考《Java多线程编程核心技术》的1.7节发现，实际上，调用interrupt方法并不能真正的停止线程，只能给线程打上一个停止的标记。但Thread中还有两个方法，分别是interrupted()和isInterrupted()</p>\n<ul>\n<li><p>interrupted</p>\n<p>在文档中是这么描述的”Tests whether the current thread has been interrupted”，也就是说，这个方法是用来测试当前线程是否被interrupte的，这点在源码中能找到证据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentThread().isInterrupted(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而currentThread()返回的是执行当前线程的线程，这个方法被标注为static方法，也就是说可以通过Thread.interrupted()来用类调用这个方法，也可以用普通的thread线程对象来调用这个方法，只不过用普通的thread线程对象来调用时，与通过类来调用的效果是一样的，并不会去判断thread类是否被中断</p>\n<p>中断thread1线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        Thread thread1 = <span class=\"keyword\">new</span> Thread(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"是否停止thread1?=\"</span>+thread1.interrupted());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是否停止thread1?=false</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>中断main线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"是否停止1?\"</span>+Thread.interrupted());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"是否停止2?=\"</span>+Thread.interrupted());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是否停止1?true</span><br><span class=\"line\">是否停止2?=false</span><br></pre></td></tr></table></figure>\n\n<p>那么又出现了一个问题：为什么第一次判断时是ture而第二次判断则为false?</p>\n<p>在文档中，对interrupted()方法的描述还有这么一句话”The <em>interrupted status</em> of the thread is cleared by this method. “也就是说这个方法将会清除线程的中断状态，接下来再看一下被interrupted()方法调用了的isInterrupted()方法。</p>\n</li>\n<li><p>isInterrupted()</p>\n<p>在文档中是这么描述的”Tests whether this thread has been interrupted. The <em>interrupted status</em> of the thread is unaffected by this method.”可以看出这个方法测试的是调用这个方法的线程对象是否被中断，并且不会清除线程的中断状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isInterrupted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isInterrupted(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，这个isInterrupted()方法还调用了另一个重载的方法，并且这个方法是private、native修饰的</p>\n<p><img src=\"https://github.com/Ethansbox/Ethansbox.github.io/blob/master/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0-01.png?raw=true\" alt=\"isInterrupted\"></p>\n<p>在注释中还提到，中断状态是否被清除，是由传入参数ClearInterrupted决定的，而interrupted()调用此方法时传入的是true，isInterrupted()调用此方法时传入的是false，这也与文档的描述相应证了。</p>\n</li>\n</ul>\n<hr>\n<p>有了这两个方法之后，就可以用类似前面那种退出标志的方法来终止线程了，这样的话不用我们自己来写控制中断线程标志的方法，但是循环之后的代码会被继续执行的问题还是没有得到解决，结合抛出异常可以解决这个问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//线程类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">500</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.interrupted())&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"已停止\"</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"异常被捕获\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        MyThread thread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        thread.interrupt();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">已停止</span><br><span class=\"line\">异常被捕获</span><br></pre></td></tr></table></figure>\n\n<p>通过这种方式，就能够达到让线程停下来的效果。</p>\n<h3 id=\"3-3线程命名\"><a href=\"#3-3线程命名\" class=\"headerlink\" title=\"3.3线程命名\"></a>3.3线程命名</h3><p>在前面分析构造线程的过程中，可以看到调用init方法时传入了一个叫name的参数，这个参数就是线程的名字，当没有调用传入线程名的构造方法时，会自动传入一个名字，这个名字为”Thread-“ + nextThreadNum()，nextThreadNum方法将会执行threadInitNumber++，threadInitNumber是一个静态成员变量，也就是说，当我们不给线程命名时，系统会自动为线程命名，并且这个命名是一个所有线程共享的计数器，每创建一个线程，这个计数器就会+1:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThreadTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            MyThread thread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">            System.out.println(thread.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-0</span><br><span class=\"line\">Thread-1</span><br><span class=\"line\">Thread-2</span><br><span class=\"line\">Thread-3</span><br><span class=\"line\">Thread-4</span><br></pre></td></tr></table></figure>\n\n<p>当我们使用线程时，最好给它指定一个名字，这对排错诊断系统监控有帮助。否则诊断问题时，无法直观知道某个线程的用途。</p>\n","categories":["并发编程"],"tags":["java","并发编程"]},{"title":"用栈实现队列","url":"http://yoursite.com/passages/算法修炼/栈和队列/用栈实现队列/","content":"","categories":["算法修炼","栈和队列"],"tags":["算法","栈和队列"]},{"title":"最小值栈","url":"http://yoursite.com/passages/算法修炼/栈和队列/最小值栈/","content":"","categories":["算法修炼","栈和队列"],"tags":["算法","栈和队列"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"categories","url":"http://yoursite.com/categories/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"http://yoursite.com/tags/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]